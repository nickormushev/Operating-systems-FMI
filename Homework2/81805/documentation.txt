Започнах си решението с няколко валидации за това дали ми се подоват под 4 аргумента. Ако са точно 4, гледам дали е правилната опция(distance)
Ако опцията е distance гледам дали аргументите са точно 4 иначе връщам съобщение за грешка. Имам глобална променлива file, която помни името 
на подадения файл, като първо правя проверка дали той може да бъде прочетен

а) + Бонус 1
Направих един case в зависимост от това коя подкоманда ми се дава и той те препраща към съответната функция.
country в зависимост от това дали CTY_FORMAT=DAT изпълнява два случая. Ако не е счита, че сме в csv формат и вика
search функцията, която рекурсивно прави grep над една променлива, като първо grep-ва за един после за два символа 
от подадената позивна и така до дължината на думата. Съответно като резултат search връща това, което е било най-дълъг exact match
на думата. Това е реда, в който се намира позивната. Затова, ако е сме в dat формат искаме да намерим и реда с името на държавата,
за която се отнася тази позивна. Това го правя като със sed принтирам редовете от настоящия до първия ред с ':', защото този символ
се намира само в редовете с имен на държавите. За целта използвам tac, за да обърна последователността на редовете във файла и да търся
отгоре надолу. Като намеря съответните редове с името на държавата с cut взимам нужната колонка и го връщам като резултат на country.

Бонус 2
Втория бонус при csv файлове го реализирах и той просто прави два search-а за частта преди последния символ '/' и за частта след.
Първо правя проверка за това дали намерения резултат е exact match или по-точно е от тип 1, защото тогават символът '/' е част от неговата
позивна. Проверявам дали има '/' и ако да и миналото условие за exact match е грешно, обръщам аргумента наобратно и взимам частта до първото
срещане на '/' и после с rev го обръщам в нормален ред. Търся за него със search и принтирам и двете.

б) + Бонус 1
Тук просто използвам search-а за да получа реда с позивната. После в зависимост от формата търся реда с името на държавата по аналогичен начин
на този в а). Там в и двата случая са стандартните ITU и WAZ номера, които присвоявам на аргументите, които връщам като резулта. Използвам 
if-ове, за да проверя дали имам приоритетен ITU и или WAZ номер. Ако да, със sed извличам измежду скобите цифрите и заменям началните им стойности.
Grep-овете търсят match започват с подадената като аргумент позивна и после да имат символ от типа '(','[', или '(<цифри>)['
Това съвпадата съответно със случай предефиниран WAZ, ITU и WAZ и ITU номер. И после sed-а взима просто цифрите между скобите и ги подава на read.

в) + Бонус 1
За бонуса тук четенето е като горе в зависимост от формата. Търси се полето с реда, съдържащ името на държават и съответно географските 
координати. Изгледах едно клипче в youtube как да изчисля разстоянието и за щастие го разбрах за разлика от множеството други грозни формули
и затов реших да използвам него. Взимам координатите и както по условие знаем те са в градуси. Сменям ги на радияни с помоща на bc, за чието
pi използвах формулата от документацията. Радианите ги превърнах от сферични в декартови координати от добре познатата формула по ДИС
и след това изчислих евклидовото разстояние между точките. Ако свържем директната права между точките да ги кръстим А и Б, а после свържем
А с О и Б с О, където О е центърът на земята получаваме АОБ равнобедрен триъгълник с ребра АО=БО. Спускаме височина H от О и тя цепи AБ на 2
Взимаме половината и с питагорова теорема смятаме ОH, защото няма arcsin в bc, и затова използвам arctg(АH/ОH), за да намеря ъгъл АОH=1/2(AOБ)
Съответно го умножих по две и се получи ъгъл AOБ, който беше целта, защото като го умножим по радиуса излиза разстоянието между точките по сферата.

Заключителни слова: На доста места ми се струва, че имам сходен код. Не съм на 100% убеден дали мога да го съкратя, т че да има смисъл. Старах
се да го разделя на възможно най-много незвисими части. Затова са отделните функции като search и прочие, които може би на моменти се нуждаят от
по-умни имена.
