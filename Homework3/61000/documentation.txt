Документация на проекта bdsm fs

Error codes:
1) Not enough argument 2) Invalid file path 3) pipe error 4) dup2 error
5) exec error 6) read error 7) write error 8) No more inodes 
9) lseek error 10) Corrupted superblock 11) Corrupted inode 
12) Failed datablock initialization 13) Trying to delete non-empty directory 
14) Not enough data blocks 15) File not found 16) Trying to lsdir a file 
17) File or directory name taken 18) File size limit
19) Deletion of root directory is formbidden 20) Failed stat 
21) Trying to delete a file with rmdir. Or a dir with rmfile 
22) Invalid command 23) Trying to print(cat) a directory

Проектът ми има за цел да реализира подобие на файлова система на езика с,
като използва структури сходни с тези от реални файлови системи като ext4 zfs
и подобни.

Аз успях да реализирам файлова система, на която се подава като глобална
костанта параметър за размера на блоковете(bloc_size) и използва това за
да създаде файлова система. За целите на файловата система съм създал
структурата Inode, която пази метаданните за файловете ми, структурата
Superblock, която пази метаданните за файловата система и структура
DirTableRow, която използва за съхранение на редове в директории, които
пазят име на файл и inode-а му. Нека първо да разгледам идеята за файловата ми система и
структурите, които съм избрал и как съм избрал какви даннит да съхраняват. 
Ще започна със Superblock-а.

Полета на Superblock:
    size_t data_block_size;
    size_t inodeSize;
    uint16_t inodesPerDatablock;
    size_t size;
    size_t filesystemSize;
    uint32_t numberOfInodes;
    uint32_t numberOfDataBlocks;
    uint32_t numberOfFreeInodes;
    uint32_t numberOfFreeDataBlocks;
    uint32_t firstFreeInode;
    uint32_t firstFreeDataBlock;
    uint64_t inodeSpace;
    uint64_t dataBlockSpace;
    uint16_t checksum;

data_block_size - стори ми се важно да пазя размера на data_block-а. По
условие трябваше да пиша на сектори от по 512 байта и затова като
глобална константа си бях сложил block_size 512 байта с цел тестване на
файловата система. Стори ми се неразумно обаче да разчитам на тази
константа и мислех, че е по-логично данните да се пазят като информация в
суперблока и затова само при инициализация използва block_size, а
навсякъде другаде се допитвам до данните в суперблока.

inodeSpace и dataBlockSpace - размера на частта от файловото пространство
заделена за inode-и и за datablock-ове. Данните се пазят в байтове. Пиша
това за всеки случай, ако не е ясно. 

Цялостно няма да хабя времето на читателя с обяснения за какво е всяко
поле като мисля, че на повечето имената са достатъчно
експресивни. Запазената в суперблока информация ми ми се стори важна метаданни за файловата
система, които мога да използвам. Количеството на данните, които пазя
може да бъде намалено, защото те могат така или иначе да бъдат по-късно
изчислени, но за да не смятам всеки път неща, като колко inode-а мога да
съхраня в един data block, реших да си ги пазя в суперблока. Не мисля, че
е най-оптимално като решение, ама цялостно вероятно моята файлова система
няма нищо общо или близко до реална оптимизирана и разработвана с години
файлова система освен базовите обекти и някои идеи. Неща като numberOfFreeInodes и
numberOfFreeDataBlock също са ненужни на принципа, че файлова
система работи леко като свързан списък или даже по-скоро стек, за да
следя кои inode-и и datablock-ове са свободни. За начало на този
списък/стек използвам firstFreeInode и firstFreeDatablock полетата. Точно
как работи това ще обясня в долната секция обаче. 
 
Полета на Inode:
    int nextFreeInode;
    int id;
    uint64_t fileSize;
    char fileType;
    uint16_t uid;
    uint16_t gid;
    char permissions[4];
    int16_t reserved;
    int dataBlocks[10];
    int doubleReferenceDataBlock;
    int trippleReferenceDataBlock;
    int blockCount;
    time_t modificationTime;
    uint16_t checksum;

id - репрезентира кой поре е inode-а. Използва се после за да се изчисли
в кой datablock трябва да отида, за да го прочета и какъв offset да
добавя. Във файла inode-ите ги записвам по ред. Съответно първо е записан
първия после втория и така нататък.

nextFreeInode - това поле е ключово за работата на файловата ми система.
За да делегирам inode-и аз помня първият свободен inode в суперблока и аналогично за
datablock-ове. Когато създавам файл или делегирам пространство на inode-е
чета първото поле от суперблока и го делегирам него. Все едно pop-вам от
върха на стека. После прочитам един фиктивен inode-е записан на мястото
на този, който пази кой е следващия свободен и това поле го присвоява
firstFreeInode в суперблока. Аналогично роботи и при datablock-овете, но
понеже те се просто байтове и нямат структура от данни, която да ги
репрезентира в началото им записвам в първите 4 байта идентификатора на
следващия data block. Когат делегирам data block-а се пише
отгоре на тези 4 байта и нерелвантната вече инфромация бива затрита.
Когато е заделен inode това поле спира да съдържа валидна информация. 
При осбождаването му то трябва да се пренасочи към бившията top на стека или просто бившия първи свободен
inode. Същото важи и за datablock-овете. Последния inode има
nextFreeInode = -1, както и последния свободен datablock. Тези данни ги
ползвам като 

dataBlocks[10] - симулира 10-те директни dataBlock-а на реалните inode-и
от файлови системи като xfs ext4. Типа е int за да може да маркирам
незаделените datablock-ове с -1.

doubleReferenceDatablock - е двойна референция, която съм реализира. Тя
сочи както при нормален inode към datablock, който пази идентификатори на
datablock-ове делегирани за inode-а

tripleReferenceDatablock - исках и него да го реализирам да работи
подобно както при реалните файлови системи, ама поради липса на време го
оставих. Искаше ми се да използвам логика подобно на doubleReference
datablock-овете и функциите, които съм написал за тях.

modificationTime - за това поле използвах функциите и структурите от
time.h, които сме използвали на практикума. Не знам дали е бело позволено и
дали е трябвало да използваме pipe-ове и date, като в последствие
изчислявам unixTime към нормално разбираемо време, ама ми се стори
прекалено да го правя така. Иначе полето пази времето в unixTime и го
конвертирам при печатане.

permissions - пазя данните във числовия формат на файловите системи,
като приемр 755. 4 са полеата заради терминиращата нула. Имам отделна
променлива за типа на обекта, към който сочи inode-а и не използвам
първия символ за да го определяма, както в други файлови системи. Първата
цифра е за потребителя, втората за групи, а третата за други. Числото 4 е
за права за четене, 2 е за права за писане, а 1 за изпълняване на файла.
Като ги сумираме получаваме число, което репрезентира правата на
потребителя групата или другите.

blockCount - това поле в началото мислех, че е ненужно, защото мислех с
помощта на размера на файла да изчислявам броя datablock-ове заделени за
него, само че това, че файла има размер нула не значи, че няма заделени
блокове. Размерът при мен репрезентира колко смислена информация има
записана и къде да започна да пиша следващия път върху обекта и докъде да
чета данните.

Полета на DirTableRow:
    uint32_t inodeId;
    char fileName[28];

Файловата система към момента поддържа имена на файлове до 28 символа,
защото не ми стигна времето да реализирам безкрайни имена. Като идея
обмислях да използвам един data block за съхранение на името или може би
цял файл, за да е наистина безкрайно. Идеята беше на мястото на името на
файла да пише inode: <inodeId> и по идентификатора на inode-а да прочета
данните от файла. С datablock щеше да е подобно.

Типовете данни на полетата на структире от сорта на това дали ще са
uint32_t или uint64_t ги избирах горе долу произволна на база дали съм си
мислел, че ще пазя по-малки или големи числа. Използвах size_t за размери
и в поседствие видях, че има и други по-експресивни типове като gid_t и
подобни, които не знам дали щеше да е по-добре да използвам или не. Не
съм ги разучвал много и с какви размери са.

Функционалност на файловата система:

mkfs - създава файловата система, като заделя първия data block за
Superblock-а. На база размера на файла подаден ми в BDSM_FS изчислявам
размера на пространството за inode-ите, като четох, че е добра идея на
всеки 2000 байта да имам по един inode(http://www.linfo.org/inode.html).
Останалото място(без първия суперблок и това за inode-ите) оставям за
datablock-овете. Във функциите initInodes и initDatablocks инициализирам
идентификаторите на inode-ите и свъразните списъци. Карам в началото
първия да сочи към втория, третия към четвъртия и така n - 1 - вия към
n-тия. Така заделянето на inode-ите и datablock-овете в началото е
оптимално, защото са близки. Схемата със свързания списък/стека е лоша,
защото след време системата е вероятно да се фрагментира и да се
делегирата блокове, които не са близки един до друг и да се изисква много
прескачане, за да се прочете файл, а seek-ването принципно е бавна
операция. Като първия опит все пак не мисля, че е лошо. Обмислях и FAT
таблица или нещо подбоно да използвам, ама така ми се строи по-лесно.
След като инициализирам inode-ите и datablock-овете ги валидирам, че са
записани правилно. Това може и да е леко ненужно, ама в началото, като си
нямах и на представа дали това, което правя работи ме успокояваше, че не
не излизат грешки след писането. На края както по спецификация създавам
root директорията, която бележа с +/ и й делегирам inode. Понеже още не е
записано нищо в нея тя няма делегирани datablock-ове. Чак когато започне
потребителя да пише в нея сметнах, че има смисъл да ги делегирам. По
време на създаването на superblock-а и заделянето на inode-и се изчислява
и тяхната checksum-а, която използвам във следващта функция. Грешките,
които тази команда хвърля са 11 за проблеми с инициализация на inode-ите
или за повредени(corrupted) inode-и. 12 за неправилно инициализирани
datablock-ове и другите са стандратни грешки за проблеми по време на
търсене, четене и писане във файал, които всички функции могат да 
хвърлят и затова няма да ги споменавам повече.

fsck - проверявам дали checksum-ата на superblock-а и inode-ите е
валидна. Идеята ми беше да използвам валидация подобна на CRC check от
мрежите, която да подсигурява, че записаните данни са валидни и че не е
имало проблем при записа. Тази проект казва дали superblock-а или някой
inode не е станал corrupted(покварил се предполагам е превода. Звучи леко
глуповато). За целта използва Fletcher16Checksum, която намерих в
уикипедия. Тя използва две суми с идеята, че втората се подсигурява, че
има значение реда на елементите, така че 1 2 3 и 3 2 1 да не генерират
една и съща checksum-а. Сумираме byte-овете на обектите и ги делим модул
255 при изчисленията. После отместваме едната суми с 8 байта и получаваме
16 байтовата cheksum-а. Също така валидирам и бройката на свободните
inode-и и datablock-ове дали съвпада с тази записана в суперблока, което
се оказа доста полезно на няколко пъти. Други валидации за
datablock-овете нямам. Исках с fsck да проверявам дали цялостната
структура на файловата ситема няма проблеми(съответно inode-ите и
superblock-а) и затова не се фокусирах върху datablock-овете, които биха
изисквали в inode-а да пазя checksum-а и за файла. Всеки datablock да
пази checksum-а за себе си ми се струва бавно за валидиране и хабене на
място. Ако един файл се повреди не мисля, че е проблем на цялата файлова
система. Затова и не съм го добавил като функционаланост. За в бъдеще
може и да преосмисля, ако продължа да я разработвам. Хвърля грешка 10) за
проблеми с superblock-а(corrupted), 11) за проблеми с inode-ите.

debug - извжда релевантните данни, които съхранявам в Superblock-а.
Прецених, че неща като firstFreeInode и firstFreeDatablock не са полезни
на крайния потребител, но бройката на свободните блокове и inode-и може
да е полезна. Също така изписах колко място е заделено за съответните
обекти(inode, datablock) в байтове. Размера на файловата система, datablock-а,
inode-a и суперблока. Колко е общия брой inode-и и datablock-ове и май
това е. Цялостно информацият в superblock-а както казах.

lsobj <path> - както е по спецификация намира, като търси обекта в дадена
директория и печата на stdout изход подобен на ls командата, както е
описано в условието. Тоест изписва типа на обекта. Правата на
потребителит в rwx формат. Времето, когато последно е модифициран файла,
име на потребител и име на група, които по подразбиране са 0 0 или
по-точно root root. Само, ако се копира файл отвън са различни. Ако
подадения обект не съществува, гърми с някои от горно описаните кодове за
грешка и съобщения за потребителя като 15) File not found и 2) Invalid
path.

lsdir <dirpath> - Работи като lsobj, само че принтира всички файлове във файла като
предварително ги извлича от директорията и ги принтира наведнъж. От
принтирането има какво да се желае, защото ако имаме редове с разминавище
се размери не е правилно подравнено печатането. Това изсква малко да
промена логиката си или да изчисля данните, които ще принтирам преди да
го направя, за да сметна най-дълги имена и да добавя към по-късите
съответни интервали. Може да го помисля за в бъдеще. Тази команда хвърля
грешка 16) Trying to lsdir a file и също така 15) File not found 2)
invalid path. Изходът на lsdir, ако файловете имат номера в тях може да
изглежда леко странен. Това е защото файловете и директориите се
сортират лексикографски, т.е. може да е леко неинтуитивно, защото
file753 е преди file9. Исках да имплементриам natural sort, но не остана
време и не ми беше приоритет. Причината да не искам да се извеждат в
реда на добавяне е, че при триене на файл от директория аз взимам
последния файл в директорията и го слагам на негово място, за да нямам
дупки и за да не ми се налага да отмествам всички други файлове. Минусът
на това е, че при следващо принтиране последния файл ще бъде принтиран
по-рано и може да обърка потребителя и да го накара да си помисли, че
той е бил изтрит, което не е така, защото просто е бил преместен.

stat <path> - разписвам stat тук понеже тя работи точно както работи lsobj и
хвърля същите грешки. Поради това използвах функция от по-висок ред,
защото единственото различно е принтирането на края. Пак намира ме файла
в съответната директория и извеждаме информация за него на екрана.
Полетата са копирани от стандратната за линукс дистрибуциите команда
стат. Взел съм всички полето, които са налични в моята файлова система.
Това са: име на файл; тип на файл; размер на файл; блоков-е заделени за
него права за достъпв в числов и rwx формат, Uid и Gid с цифри и думи,
както и време на последна модификация на файла.

mkdir <dirpath> - създава директория. Ако има файл с това име изписвам
грешка 17) File directory name taken. Може да изведе грешка и ако не
стига броя на inode-ите или на datablock-овете. 

rmdir <dirpath> - трие празна директория и се оплаква, ако не е празна
или не е директория, а и ако не съществува. Грешките са описани по-горе.
Не може да се трие +/ директорията.

rmfile <filepath> - трие файл и реве, ако е подадена директория или
несъщствуващ файл. Грешките ги има в началото на този файл.

cpfile <src file> <dest file> - копира файл от моята файлова система към
външната или обратно. Ако копираме към външната и е подаден несъществуващ
файл той е създаден с права 644 както по условие. Също така не се
променята метаданните, ако файла вече е съществувал, така че да съвпадат
с тези на моята файлова система. Ако не е съществувал също не се сменя
gid-то на потребителя както и uid-то. Те са тези на този, който е
стартирал програмата. От друга страна, ако копираме от външната файлова
система към моята, правата на файла се запазват каквито са били. Също
така се копира gid и uid на външния потребител. Понеже не бях прочел условието
правилно и не бях разбрал, че трябва да презаписвам файл, ако той вече съществува
в моята файлова система набързо го оправих като накарах rm командата, която
използвам за rmfile и rmdir да приема файлов дескриптор fd и open да се изпълнява
на по-ранен етап. Цялостно може всичките функции да приемата просто фйалов дескриптор и
да се отварят предварително в main функцията, ама това не знам колко е от значение
и е малко оптимизация.

cat <filepath> - стори ми се лесна команда за имплементиране след cpfile,
защото реално прави същото, само че вместов във файл пише на stdout.
Оплаква се, ако се опитваме да подадем директория с грешка 23)

help - изпосва командите, които съм имплементирал и техния синтаксис

От стандартните бонуси нищо не съм реализирал, защото идват контролни и
изпити и цялостно нямам времето, а и колкото и да ми беше приятно да
пиша тази файлова система, нямам много време да продължа да я разработвам
към момента. Иначе е много готин проектът и се чувствам все едно вече съм
направил нещо, което наподобява реална работа на ниско ниво с един
компютър и ми подобри разбирането на файлови системи и как работят.
Цялостно може би това беше най-интересния проект, който съм правил досега
във ФМИ, но може би е и най-трудния да се започне. Все пак, като
потръгнаха нещата, поддържах малко по-добро темпо, ама пак не
стигна времето за всичко. Абе цялостно проектът беше свръх готин така
или иначе!

Други функционалности, с които мога да развия проекта си: 

Тройни указатели към файлове, че в момента с блокове за 512 байта и само двойни
указатели размерите на файловете са много малки. Дори с троен указател
при този block size ще съм с 8.5MB максимален размер на файл.

Лексикографската сортировка да се замени с natural sort, така че изходът
на lsdir да е по интуитивен при числа.

Да се оправи lsdir, т че да е подравнен изхода винаги, като добавя
толкова празни пространства колкото е и най-дългия елемент в колоната

Бонусите за soft и hardlink-ове както и chmod и други.

Работа с релативни пътища, така че да записвам в някакъв файл до кой файл
съм стигнал и да мога да използвам команди като cd и подобни.

Реализация на cpfile между файлове от моята файлова система не само за
навън и обратно.

touch може да се имплементира за създаване на файлове.

mv за копиране на файлове и редактиране. Даже mv вероятно с комбинация от
модифицирания отгоре cpfile и rmdir/rmfile ще стане лесно.

Много други...
