Error codes:
1)Not enough argument 2)Open file error 3)pipe error 4)dup2 error 5)exec error 6) read error 7) write error 
8)No more inodes 9) lseek error 10) Corrupted superblock

Day 1: Started by reareading the problem.txt a few time. Found out I did not understand all of it at
first.  I was expecting to have to access the memory directly in some way so I could write my files
to it, but eventually I understood that it was just the single file through which we would do it by
saving and reading the information to it. 

I remembered what inodes were and I knew more or less how to include them but the superblock was
another story. I was also not sure how to divide up my memory into appropriate chunks so I have
enough inodes.  I decided after a bit of reading and finding Linus Torvald's github with file
systems like ext4 and zfs to begin writing some code. For a start I needed to read the environment
variable and I googled and found the getenv command.  Read the file and decided to get its size.
Made sure that was working so I went on to division of memory.

I also decided due to lack of time that my datablock size would be equal to 512 bytes. A data block
can be larger but that would lead to greater wastage of memory if I am storing small files. The
small blocks lead to more metadata to keep track of but for now this looks like the easier route.

Late at night the same day: I found this link as a resource from the wikipedia page on inodes:
http://www.linfo.org/inode.html . After reading I found out that the typical heuristic for a file
system is to have one inode per 2K bytes. Will implement tommorow!  An inode without the name is 20
bytes. Let's make it 30 for the name even though it can be longer. We have 16777 inodes for 32 MB of
starage. 

Day 2: Forgot that I had to add the dataBlock[10] array that pointed to the dataBlocks used by the
file and on top of that the double and triple pointer dataBlocks that point to other dataBlocks. As
of now I imagine them as offsets in the file so I suppose they will be integers. That might change
though. Also forgot that I needed the name size so I know how many bytes to read.  The actual size
now became 80 bytes for a single inode with 10 bytes for the name so the above calculations are
false. 

Day 3: I asked Angel for help and understood that it is a good idea not to save the name of a file
in an inode but instead in the directory that contains it as a map between the inode and the name of
the file. This was actually a pretty good idea and meant that the inode is a fixed size, meaning I
can easily search for it.  Solved a ton of the issues of writing the inode and made it so I could
finally implement mkfs fully. Decided I should finally decide on error codes. They will be at the
top of this file!  Might use this idea to store the name of a file if it is larger than x number of
bytes, where x is the limit of the fileNames for the table.

I need to think of what I want in the superblock exactly. Seems it would be appropriate to have the
free data blocks and the ones in use.  This would help with determining what datablocks to give out
when writing to a file and in need of more space. This might be needed for the inodes aswell since I
can't just remember the last inode written. As of this moment I am definitely lacking this
functionality and I am unsure of how to implement it. Maybe the size of the superblock will be
detirmined based on the size of the give file(take the number of data blocks and Inodes and have an
array of numbers that determines which ones are free and which ones aren't), maybe I can have a flag
an search linearly. The above means I need the number of inodes and the number of data blocks in the
superblock aswell. Also I want to number my inodes sequentially so I can easily find them by using
their size.

Actual number of inodes is still 16777 for 32MB which I multiplied by 64 which as of now is the size
of a single Inode.  This is around 1 MB of the whole file.

Day 4: I decided to have a dynamic arrays of free datablocks and inodes in my superblock that I will
give out when they are needed. This will work like a stack like memory. When I create the superblock
during mkfs all inodes and dataBlocks will be free. An index will point to the top of the stack.
When I give out and inode I will move the index downwords and when I free up an inode I will
increase it and on that spot place the id of the now free inode. The same goes for the datablock. In
time this might lead to issues because I will give out datablocks randomly and not based on spatial
locality to the file, but I honestly will be glad if my filesystem works by the end date.

The inode and datablock id's will be sequential from 0 to n - 1. This way if I give write to
datablock with index i I can just lseek to i * data_block_size + data_block_start_offset and write
there. Started working on this idea but I hit a dead end. If the superblock is dynamic that means
that I can not calculate how many datablocks I need

Day 5: Finally after some exams I have time to write the filesystem. I still struggled with keeping
track of the free space I had. I was thinking of a stack like structures but the dynamic memory that
was required in the superblock caused more headaches than it solved. I finally decided to look at a
real superblock and searched for the ext4 one.  In the process I found this
link(https://ext4.wiki.kernel.org/index.php/Ext4_Disk_Layout#Data_Block) and was suprised to find
out that the superblock just had the count of the free inodes and data blocks, but didn't bother
with knowing which they were. The only metadata it had conserning this is the first free inode.
Googled some more and found this site:
https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/12_FileSystemImplementation.html which
looked promising and it was. At the section of free-space management I saw the different options
that normal file systems use to solve this issue and looking at the picture of a linked list it gave
me the idea to modify my stack idea and make it work like a the linked stack in the picture. What do
I mean?  Well every free inode will keep the index of the next one as part of its metadata. The
superblock will point to the first free inode. Once an inode needs to be allocated it will give out
the first and it will start pointing to it's child. When a file is deleted a the newly freed inode
will start pointing to the old top of the stack and the superblock will remember it's index! The
same logic will be applied to the data blocks to keep track which are free and which aren't. If the
nextFreeInodeId = -1 that means the inode is allocated and in use so this field is meaningless.

Decided to leave the entire first 512 bytes for the superblock. The idea is that it would be easier
to search if I didn't have to take into account a superblocks aswell. I know actual file systems
save the superblock after every x number of inodes but here this just seemed simpler. If I have time
might want to refactor.

Finally managed to finish the mkfs command and I am glad. The linked list/stack idea seems to have
prooved a good idea. Overall I know this might be slow in the long run especially if you consider
that seeking is the slowest part of working with a hard disk. The random allocation of data blocks
means that in time the files will have been allocated data_blocks that are far apart and not in
ascending order based on offset. This will lead to a lot of seeking back and forth and will be
indeed slow, but I think it is good enough for my first try while still learning and trying to
minimize the awful math.

I finally calculated the required space for the inodes correctly. Previously I was faced with issues
conserning offsets. Deciding to check how many inodes I can have in a single data_block lead to the
correct approach. After that I made the desired amount of datablocks a multiple of those per single block
and divided the first by the second. This gave me the needed amount of datablocks to store all my
inodes. Then I multiplied the number of datablocks by their size and got the inodeSpace.

Day 6:
I could not do as much as I wanted to due to lack of time but still I was happy at least mkfs
worked.  Decided to keep the fileSize inside the inode so I know what I wanted to read and went onto
considering how to check validity for fsck. For now I am unsure how to see if data has been
corrupted except by using some sort of hash which seems a bit too much. I remembered the CRC check
used in networking to calculate a checksum for packets to detirmine if they were modified during
trasmission. I decided to look into a simple checksum algorithm to see if data has been corrupted. I
found the Fletcher's Checksum algorithm which takes the idea of a simple checksum that just adds up
the fields of data and divides by modulus x and modifies it so it does not have the issue of only
having x possible states and also gives importance to the order of the values so that 10 11 12 don't
give the same checksum as 12 11 10. It solves the first and second issue by adding a second sum. We
add to it the values of the original sum on every iteration. This means that if 10 is the first
value it would be added 3 times to the second sum. So the position now matters and the checksum of
the above example will not be the same. We divide by modulus 255 for Fletcher16, because we need to
keep the values in the first part of the 16 bytes to zero so we can combine the two values of the
first and the second sum in the end using a logical or and shifting the data to the left. Here is
the link to the algorithm on wikipedia. I took the code from here though it is pretty easy to
implement when you understand how and why it works:
https://en.wikipedia.org/wiki/Fletcher%27s_checksum

The issue I faced now was how to convert my structure into integer bytes so could add them up and
calculate the sum. I thought of writing them to the file and then reading the data, but that could
mean that during writing the data could get corrupted and the whole of idea of the checksum becomes
pointless. Then I googled believing that there needs to be a way to treat the structure as an array
of bytes and sure enough there was. This is really smart and gave me a new appreciation of pointers.
Found this stack overflow page:
https://stackoverflow.com/questions/484357/trying-to-copy-struct-members-to-byte-array-in-c which
pointed out that I could just get the address of the structure in memory and convert it to a 
uint8_t *byteArray. I could not believe I could do something like that which is so logical and
fascinating. As I said pointers are awesome!!!! Now I could use the Fletcher checksum algorithm.

I met with another issue! Calculating the value of the checksum lead to me changing the superblock and inode
data so when I calculte it a second the the result would be different. I remembered I saw some checkbytes 
in the wikipedia article for the checksum. They were made so on recalculation of the sum the checksum would
give 0x00 as an answer and this looks like the right solution for me.

The above idea failed. The algorithm did not output 0x00 and i decided just to make the checksum value equal
zero temporarily so the value calculated is the same. Seemed simpler.

I tried to do the same for the Inodes but that did not work because they have a pointer(the array) which
initialized with a different value every time I ran the program. I could use memcopy and write the data to an array of
uint8_t bytes but since we haven't studied it i decided against that. If I have time I might revisit and fix this.
I do not know if this idea is a good one aswell cause I would not be validating the files that contain id's aswell.
Need to write a custom function that does that. I will try to add it later as i said.

The last idea I have for fsck is to check if the amount of free Inodes is equal to the amount specified in the superblock
Same could be done for the datablocks. I can just walk through the inodes and datablocks and see if the numbers match.
I believe that fsck has the idea of validating the structure of the file system and not all files. So I will not be looking at
data blocks.
